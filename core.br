[import lib.core lib]
[import [lib.core add mul sub div gt lt lte gte exit cons symbol pformat dropv count apply sortby kwapply in_]]
[import [naga append conj first last rest get drop assoc mapv partition inc dec second LazySeq some]]
[import [naga take]]
[import naga]
[import [lib.special_forms Set HashMap]]
[import operator op]
[import itertools]
[import pickle]

[defmacro . [obj attr . args]
            [let [attr [py/str attr]]
                 `[[py/getattr ,obj ,attr] ,-args]]]

[defmacro .- [obj attr]
     [let [attr [py/str attr]]
          `[py/getattr ,obj ,attr]]]

[def lazy-seq LazySeq]

[def nil lib/nil]

[def < lt]
[def > gt]
[def <= lte]
[def >= gte]
[def = lib/eq]
[def is? lib/eqq]
[def eq? lib/eqq]

[def != lib/neq]
[def - sub]

[defn type? [x] [py/type x]]

[defn isa? [x types] [py/isinstance x types]]

[def empty? lib/empty]

[def int py/int]
[def float py/float]
[def tuple py/tuple]

[defn int? [x] [isa? x int]]

[defn mod [a b] [op/mod a b]]

[defn zero? [x] [= 0 x]]

[defn even? [x] [zero? [mod x 2]]]

[def false? lib/false_]

[def not lib/not_]

[def list? lib/listp]

[def null? lib/nullp]

[def symbol? lib/symbolp]

[def list lib/list_]

[def list* lib/to_list]

[def bool? lib/boolean]

[def bool py/bool]

[def range py/range]

[defn subvec [[]                     []]
             [[xs]                   xs]
             [[xs start]            [. xs __getitem__ [py/slice start [count xs]]]]
             [[xs start stop]       [. xs __getitem__ [py/slice start stop]]]
             [[xs start stop step]  [. xs __getitem__ [py/slice start stop step]]]]



[def t true]
[def f false]

[def set Set]

[defn butlast [x] [[.- x __getitem__] [py/slice 0 -1]]]

[defn assert
    [[exp res]     [let [msg [pformat 'expecting {}, got {}' exp res]]
                     [assert exp res msg]]]
    [[exp res msg] [if [= exp res]
                       true
                       [begin [print msg] false]]]]


[defn hashmap [[] [py/dict]]
          [[. xs] [py/dict [partition 2 xs]]]]

[defn into [[]    []]
           [[x]   [into [py/list] x]]
           [[a b] [if [empty? b]
                      a
                      [into [conj a [first b]]
                            [rest b]]]]]

[defmacro xrange [. args] `[list* [range ,-args]]]

[defmacro imply [f . xs]
          [if [list? [last xs]]
              `[imply ,f ,-[butlast xs] ,-[last xs]]
              `[,f [,-xs]]]]

[defn print [[x]      [py/print x]]
            [[x . xs] [apply py/print x xs]]]


[defmacro and [[] true]
             [[x]    x]
        [[x . xs]
        `[let [y ,x] [if y [and ,-xs] y]]]]


[defmacro or [[] true]
            [[x]    x]
      [[x .  xs]
       `[let [y ,x] [if y y [or ,-xs]]]]]


[defmacro when [test . body] `[if ,test [begin ,-body]]]

[defmacro cond
          [[a] a]
          [[a b]
           `[if ,a ,b nil]]
          [[a b . clauses]
            [if [= 0 [count clauses]]
                `[cond ,a ,b]
                `[if ,a
                     ,b
                     [cond ,-clauses]]]]]

[defmacro case
    [[e] false]
    [[e a] a]
    [[e . clauses] [let [[a b . clauses] clauses]
                     `[if [= ,e ,a]
                          ,b
                          [case ,e ,-clauses]]]]]

[defmacro ->
   [[e . forms] [let [[form . forms] forms
                      [f . body] [if [list? form] form [list form]]]
                      `[-> [,f ,e ,-body] ,-forms]]]
   [[e] e]]

[defmacro ->>
   [[e . forms] [let [[form . forms] forms
                      [f . body] [if [list? form] form [list form]]]
                      `[->> [,f ,-body ,e] ,-forms]]]
   [[e] e]]


[defmacro threadfirst [. exps] `[-> ,-exps]]

[defmacro threadlast [. exps] `[->> ,-exps]]


[defn kw->fn- [exp]
   [let [replace [.- exp replace]
         r       [replace '-' '']
         join    [.- '' join]]
         [join   [list r '-']]]]


[defmacro pre-for
           [[bindings body]
            [let [bindings [mapv list* [partition 2 bindings]]]
                  `[pre-for [] ,bindings ,body]]]

           [[acc bindings body]
            [if [empty? bindings]
                `/[-> ,body ,-acc]
                [let [[exp . bindings] bindings
                      [f s] exp
                      sx   [set /[-for -when -while -let]]
                      kw?  [sx f]]
                   [if kw?
                       `[pre-for ,[conj acc [list [kw->fn- f] s]] [,-bindings] ,body]
                       `[pre-for ,[conj acc [list /for- [f s]]] [,-bindings] ,body]]]]]]


[defmacro for
          [[bindings body] `[for [] [] ,bindings ,body]]
          [[acc body-acc bindings body]
           [print bindings]
           ;[let [[a b] bindings]
           ;   [print [get &env 'a']]
           ;   [print [eval `,b &env]]
           ;   ]
           [if [empty? bindings]
               [begin [import [lib.loadbr brfn]]
                      [let [globals   [. [py/globals] update [hashmap 'brfn' brfn 'global_env' &env]]
                            for-loop  [pformat '[[{}] {}]' [. ', ' join body-acc] [. ' ' join acc]]
                            _         [print for-loop]
                            results   [py/eval for-loop globals &env]
                            f         `[fn [,body-acc] ,body]
                            r          `[mapv ,f ,results]]
                            [print f]
                            [print r]
                            r]]
               [let [[a b . bindings] bindings]
                    [case a
                          -when [let [b-args [mapv [fn [x] [-> x py/str [. replace '\'', '']]] [subvec b 1]]
                                      b      [cons b b-args]
                                      py-if  [pformat 'if brfn(*{})' b]]
                                  `[for [,-acc ,py-if] ,body-acc ,bindings ,body]]
                         -while `[for ,acc ,[conj bindings -when b] ,body]

                          ; for
                          [let [args   [. ', ' join [mapv py/str [subvec b 1]]]
                               bfmt    [pformat 'brfn(*{})' b]
                               py-for  [pformat 'for {} in {}' a bfmt]]
                            `[for [,-acc ,py-for] [,-body-acc ,a] ,bindings ,body]]]]]]]


; [defmacro for2 [[seq-exprs body-expr]]


[defn take-while
      [[pred xs]     [take-while [] pred xs]]
      [[acc pred xs] [cond       [empty? xs]       acc
                                 [pred [first xs]] [take-while [conj acc [first xs]] pred [rest xs]]
                                   acc]]]

[defmacro comment [. body] py/None]

[defn concat [. strs] [. '' join strs]]

[defn s-join [s . ss] [. s join ss]]

[defn take-first [f xs]
      [let [[x . xs] xs]
            [if [f x]
                x
                [take-first f xs]]]]

[defn nil? [x] [or [= x nil] [= x py/None] [= [type? x] [type? py/None]]]]

[defmacro defprotocol [name . opts+sigs]
    [print name opts+sigs]
    [let [[[fname fsigs] . opts+sigs] opts+sigs]
          [print fname fsigs opts+sigs]
          [if [nil? [get *env* [py/str fname]]]
              [let [f `[defn ,fname [,-fsigs] nil]]
                [print f]
                [eval f]]]]]

[defn sort [coll] [py/sorted coll]]

[defn sort-by [[key coll] [kwapply py/sorted coll [hashmap 'key' key]]]
              [[key]      [fn [coll] [sort-by key coll]]]]

[def in? in_]

[defn juxt [. fs]
   [defn juxt- [x acc fs]
      [cond [empty? fs] acc
            -else       [let [[f . fs] fs
                              acc      [conj acc [f x]]]
                          [juxt- x acc fs]]]]
   [fn [x] [juxt- x [] fs]]]

